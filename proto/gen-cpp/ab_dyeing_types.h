/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ab_dyeing_TYPES_H
#define ab_dyeing_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace inveno {

struct ab_status {
  enum type {
    RC_STATUS_OK = 0,
    RC_SERVER_ERROR = 1,
    RC_SERVER_FAULT = 2,
    RC_UNKNOW_ERROR = 3
  };
};

extern const std::map<int, const char*> _ab_status_VALUES_TO_NAMES;


class ABDyeingRequest {
 public:

  static const char* ascii_fingerprint; // = "8E2AD6401E83558ECFD6A13D74DD0A3F";
  static const uint8_t binary_fingerprint[16]; // = {0x8E,0x2A,0xD6,0x40,0x1E,0x83,0x55,0x8E,0xCF,0xD6,0xA1,0x3D,0x74,0xDD,0x0A,0x3F};

  ABDyeingRequest() : app(), app_ver() {
  }

  virtual ~ABDyeingRequest() throw() {}

  std::string app;
  std::string app_ver;
  std::vector<std::string>  _types;

  void __set_app(const std::string& val) {
    app = val;
  }

  void __set_app_ver(const std::string& val) {
    app_ver = val;
  }

  void __set__types(const std::vector<std::string> & val) {
    _types = val;
  }

  bool operator == (const ABDyeingRequest & rhs) const
  {
    if (!(app == rhs.app))
      return false;
    if (!(app_ver == rhs.app_ver))
      return false;
    if (!(_types == rhs._types))
      return false;
    return true;
  }
  bool operator != (const ABDyeingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingRequest &a, ABDyeingRequest &b);


class ABDyeingLanRequest {
 public:

  static const char* ascii_fingerprint; // = "D5082811F603CA229965DA45DAFDD5B7";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x08,0x28,0x11,0xF6,0x03,0xCA,0x22,0x99,0x65,0xDA,0x45,0xDA,0xFD,0xD5,0xB7};

  ABDyeingLanRequest() : app(), app_ver(), app_lan() {
  }

  virtual ~ABDyeingLanRequest() throw() {}

  std::string app;
  std::string app_ver;
  std::string app_lan;
  std::vector<std::string>  _types;

  void __set_app(const std::string& val) {
    app = val;
  }

  void __set_app_ver(const std::string& val) {
    app_ver = val;
  }

  void __set_app_lan(const std::string& val) {
    app_lan = val;
  }

  void __set__types(const std::vector<std::string> & val) {
    _types = val;
  }

  bool operator == (const ABDyeingLanRequest & rhs) const
  {
    if (!(app == rhs.app))
      return false;
    if (!(app_ver == rhs.app_ver))
      return false;
    if (!(app_lan == rhs.app_lan))
      return false;
    if (!(_types == rhs._types))
      return false;
    return true;
  }
  bool operator != (const ABDyeingLanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingLanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingLanRequest &a, ABDyeingLanRequest &b);


class ABDyeingUidReqInfo {
 public:

  static const char* ascii_fingerprint; // = "9BE6BE471EA55C3896E16579016D30E0";
  static const uint8_t binary_fingerprint[16]; // = {0x9B,0xE6,0xBE,0x47,0x1E,0xA5,0x5C,0x38,0x96,0xE1,0x65,0x79,0x01,0x6D,0x30,0xE0};

  ABDyeingUidReqInfo() : uid() {
  }

  virtual ~ABDyeingUidReqInfo() throw() {}

  std::string uid;
  ABDyeingRequest _uid_info;

  void __set_uid(const std::string& val) {
    uid = val;
  }

  void __set__uid_info(const ABDyeingRequest& val) {
    _uid_info = val;
  }

  bool operator == (const ABDyeingUidReqInfo & rhs) const
  {
    if (!(uid == rhs.uid))
      return false;
    if (!(_uid_info == rhs._uid_info))
      return false;
    return true;
  }
  bool operator != (const ABDyeingUidReqInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingUidReqInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingUidReqInfo &a, ABDyeingUidReqInfo &b);


class ABDyeingUidLanReqInfo {
 public:

  static const char* ascii_fingerprint; // = "C393B87B4067961C69A1CE411982877D";
  static const uint8_t binary_fingerprint[16]; // = {0xC3,0x93,0xB8,0x7B,0x40,0x67,0x96,0x1C,0x69,0xA1,0xCE,0x41,0x19,0x82,0x87,0x7D};

  ABDyeingUidLanReqInfo() : uid() {
  }

  virtual ~ABDyeingUidLanReqInfo() throw() {}

  std::string uid;
  ABDyeingLanRequest _uid_lan_info;

  void __set_uid(const std::string& val) {
    uid = val;
  }

  void __set__uid_lan_info(const ABDyeingLanRequest& val) {
    _uid_lan_info = val;
  }

  bool operator == (const ABDyeingUidLanReqInfo & rhs) const
  {
    if (!(uid == rhs.uid))
      return false;
    if (!(_uid_lan_info == rhs._uid_lan_info))
      return false;
    return true;
  }
  bool operator != (const ABDyeingUidLanReqInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingUidLanReqInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingUidLanReqInfo &a, ABDyeingUidLanReqInfo &b);


class ABDyeingBatchRequest {
 public:

  static const char* ascii_fingerprint; // = "F938BDB6ACACAE9A2E45992B2DE4F21F";
  static const uint8_t binary_fingerprint[16]; // = {0xF9,0x38,0xBD,0xB6,0xAC,0xAC,0xAE,0x9A,0x2E,0x45,0x99,0x2B,0x2D,0xE4,0xF2,0x1F};

  ABDyeingBatchRequest() {
  }

  virtual ~ABDyeingBatchRequest() throw() {}

  std::vector<ABDyeingUidReqInfo>  _uid_req_infos;

  void __set__uid_req_infos(const std::vector<ABDyeingUidReqInfo> & val) {
    _uid_req_infos = val;
  }

  bool operator == (const ABDyeingBatchRequest & rhs) const
  {
    if (!(_uid_req_infos == rhs._uid_req_infos))
      return false;
    return true;
  }
  bool operator != (const ABDyeingBatchRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingBatchRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingBatchRequest &a, ABDyeingBatchRequest &b);


class ABDyeingBatchLanRequest {
 public:

  static const char* ascii_fingerprint; // = "7A37B6B335A2B048A2C50259EEDCC134";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0x37,0xB6,0xB3,0x35,0xA2,0xB0,0x48,0xA2,0xC5,0x02,0x59,0xEE,0xDC,0xC1,0x34};

  ABDyeingBatchLanRequest() {
  }

  virtual ~ABDyeingBatchLanRequest() throw() {}

  std::vector<ABDyeingUidLanReqInfo>  _uid_lan_req_infos;

  void __set__uid_lan_req_infos(const std::vector<ABDyeingUidLanReqInfo> & val) {
    _uid_lan_req_infos = val;
  }

  bool operator == (const ABDyeingBatchLanRequest & rhs) const
  {
    if (!(_uid_lan_req_infos == rhs._uid_lan_req_infos))
      return false;
    return true;
  }
  bool operator != (const ABDyeingBatchLanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingBatchLanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingBatchLanRequest &a, ABDyeingBatchLanRequest &b);


class ABDyeingEntry {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  ABDyeingEntry() : type(), config_id() {
  }

  virtual ~ABDyeingEntry() throw() {}

  std::string type;
  std::string config_id;

  void __set_type(const std::string& val) {
    type = val;
  }

  void __set_config_id(const std::string& val) {
    config_id = val;
  }

  bool operator == (const ABDyeingEntry & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(config_id == rhs.config_id))
      return false;
    return true;
  }
  bool operator != (const ABDyeingEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingEntry &a, ABDyeingEntry &b);

typedef struct _ABDyeingReply__isset {
  _ABDyeingReply__isset() : _entries(false) {}
  bool _entries;
} _ABDyeingReply__isset;

class ABDyeingReply {
 public:

  static const char* ascii_fingerprint; // = "101E22EEE714785E462FCF6056B14937";
  static const uint8_t binary_fingerprint[16]; // = {0x10,0x1E,0x22,0xEE,0xE7,0x14,0x78,0x5E,0x46,0x2F,0xCF,0x60,0x56,0xB1,0x49,0x37};

  ABDyeingReply() : status((ab_status::type)0) {
  }

  virtual ~ABDyeingReply() throw() {}

  ab_status::type status;
  std::vector<ABDyeingEntry>  _entries;

  _ABDyeingReply__isset __isset;

  void __set_status(const ab_status::type val) {
    status = val;
  }

  void __set__entries(const std::vector<ABDyeingEntry> & val) {
    _entries = val;
    __isset._entries = true;
  }

  bool operator == (const ABDyeingReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset._entries != rhs.__isset._entries)
      return false;
    else if (__isset._entries && !(_entries == rhs._entries))
      return false;
    return true;
  }
  bool operator != (const ABDyeingReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingReply &a, ABDyeingReply &b);


class ABDyeingUidRepInfo {
 public:

  static const char* ascii_fingerprint; // = "E09E9FECEBC4573D5CC6E2BEB8658A51";
  static const uint8_t binary_fingerprint[16]; // = {0xE0,0x9E,0x9F,0xEC,0xEB,0xC4,0x57,0x3D,0x5C,0xC6,0xE2,0xBE,0xB8,0x65,0x8A,0x51};

  ABDyeingUidRepInfo() : uid() {
  }

  virtual ~ABDyeingUidRepInfo() throw() {}

  std::string uid;
  ABDyeingReply _uid_rep;

  void __set_uid(const std::string& val) {
    uid = val;
  }

  void __set__uid_rep(const ABDyeingReply& val) {
    _uid_rep = val;
  }

  bool operator == (const ABDyeingUidRepInfo & rhs) const
  {
    if (!(uid == rhs.uid))
      return false;
    if (!(_uid_rep == rhs._uid_rep))
      return false;
    return true;
  }
  bool operator != (const ABDyeingUidRepInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingUidRepInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingUidRepInfo &a, ABDyeingUidRepInfo &b);

typedef struct _ABDyeingBatchReply__isset {
  _ABDyeingBatchReply__isset() : _uid_rep_infos(false) {}
  bool _uid_rep_infos;
} _ABDyeingBatchReply__isset;

class ABDyeingBatchReply {
 public:

  static const char* ascii_fingerprint; // = "39BA943D70B6558920B6773DA6E916CF";
  static const uint8_t binary_fingerprint[16]; // = {0x39,0xBA,0x94,0x3D,0x70,0xB6,0x55,0x89,0x20,0xB6,0x77,0x3D,0xA6,0xE9,0x16,0xCF};

  ABDyeingBatchReply() : status((ab_status::type)0) {
  }

  virtual ~ABDyeingBatchReply() throw() {}

  ab_status::type status;
  std::vector<ABDyeingUidRepInfo>  _uid_rep_infos;

  _ABDyeingBatchReply__isset __isset;

  void __set_status(const ab_status::type val) {
    status = val;
  }

  void __set__uid_rep_infos(const std::vector<ABDyeingUidRepInfo> & val) {
    _uid_rep_infos = val;
    __isset._uid_rep_infos = true;
  }

  bool operator == (const ABDyeingBatchReply & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset._uid_rep_infos != rhs.__isset._uid_rep_infos)
      return false;
    else if (__isset._uid_rep_infos && !(_uid_rep_infos == rhs._uid_rep_infos))
      return false;
    return true;
  }
  bool operator != (const ABDyeingBatchReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ABDyeingBatchReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ABDyeingBatchReply &a, ABDyeingBatchReply &b);

} // namespace

#endif
